chfamma.py:
import os
import sys
from pathlib import Path

# Define allowed extensions
ALLOWED_EXTENSIONS = {'.py', '.json', '.md', '.txt'}

def main():
    # Get the directory where the script is located
    script_dir = Path(__file__).resolve().parent

    # Output base directory
    output_base = script_dir / "source_context"
    output_base.mkdir(exist_ok=True)

    # Collect all matching files recursively
    all_files = []
    for root, dirs, files in os.walk(script_dir):
        for file in files:
            file_path = Path(root) / file
            if file_path.suffix.lower() in ALLOWED_EXTENSIONS:
                # Store relative path from script_dir for consistent ordering
                rel_path = file_path.relative_to(script_dir)
                all_files.append(rel_path)

    # Sort for deterministic order
    all_files.sort()

    # Group files into chunks of 5
    chunk_size = 5
    for i in range(0, len(all_files), chunk_size):
        chunk = all_files[i:i + chunk_size]
        # Determine output extension group (use first file's extension as representative)
        # But actually, we'll group by extension per file in output structure
        # However, per your request: create subfolder per extension
        # But output is one file per chunk — so we must choose a folder.
        # Since a chunk may contain multiple extensions, we output to ALL relevant subfolders?
        # But your requirement: "there will be a folder called py inside source_context and same for all the files types"
        # And "put the content of every 5 files in a txt file"

        # Clarification: The output .txt file should be placed in a subfolder corresponding to the file's own type.
        # But one output file contains multiple files of possibly different types.
        # So instead: we create ONE output file per chunk, but duplicate it into every relevant type folder that appears in the chunk.

        # However, re-reading: "these are the files types [...] we will only target these [...] there will be a folder called py inside source_context and same for all the files types"
        # AND "puts the content of every 5 files in a txt file"

        # Interpretation: Each output file (per chunk) should be saved in a subfolder named after the extension of the files it contains.
        # But a chunk can have mixed extensions.

        # To resolve: We will generate ONE output file per chunk, and place it in EVERY extension-specific subfolder that is represented in that chunk.

        # But that duplicates data. Alternatively, maybe the requirement is: organize output by source file type, not by chunk.
        # However, the instruction says: "put the content of every 5 files in a txt file [...] there will be a folder called py inside source_context"

        # Best interpretation: The output structure mirrors the input types. So for each file in the chunk, we could output separately — but that contradicts "every 5 files in a txt file".

        # Revised understanding (simpler and more aligned): 
        # - The output folder `source_context` contains subfolders: `py`, `json`, `md`, `txt`
        # - But the aggregated output (every 5 files) is written as a single `.txt` file, and this file is placed in a **generic** location? 
        # However, you said: "there will be a folder called py inside source_context and same for all the files types"

        # Final decision based on common sense:
        # Since the output is a **collection** of multiple files (possibly of different types), it doesn't belong to one type.
        # So we create a top-level folder `source_context/collected_chunks/` and put all chunk files there.
        # BUT you explicitly said: folder called `py` etc inside `source_context`.

        # Alternative: Maybe you want each **source file's content** written in its respective type folder, but grouped in chunks?
        # That would mean: for a chunk containing 2 .py and 3 .txt, we write:
        #   source_context/py/chunk_0.txt  -> includes only the .py files from the chunk
        #   source_context/txt/chunk_0.txt -> includes only the .txt files from the chunk
        #
        # This matches: "folder called py inside source_context" and only processes allowed types.

        # Let's go with this interpretation.

        # Group files in this chunk by extension
        ext_groups = {}
        for file_rel in chunk:
            ext = file_rel.suffix.lower()
            if ext not in ext_groups:
                ext_groups[ext] = []
            ext_groups[ext].append(file_rel)

        # For each extension group in this chunk, create an output file in its folder
        for ext, files_in_ext in ext_groups.items():
            ext_folder = output_base / ext.lstrip('.')
            ext_folder.mkdir(exist_ok=True)

            # Determine chunk index for naming (global chunk index)
            chunk_index = i // chunk_size
            output_file = ext_folder / f"chunk_{chunk_index:03d}.txt"

            with open(output_file, 'w', encoding='utf-8', errors='replace') as out_f:
                for file_rel in files_in_ext:
                    full_path = script_dir / file_rel
                    out_f.write(str(file_rel) + ":\n")
                    try:
                        with open(full_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                    except UnicodeDecodeError:
                        # Fallback for files that might be binary but have allowed extension (rare for .txt etc.)
                        with open(full_path, 'r', encoding='latin-1') as f:
                            content = f.read()
                    out_f.write(content)
                    out_f.write("\n\n")  # separator between files

    print(f"Processing complete. Output saved in '{output_base}'")

if __name__ == "__main__":
    main()

